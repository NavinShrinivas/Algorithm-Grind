#include "header.h"
#include <limits.h>
#include <stdio.h>

// ANY STATIC FUNCTIONS ARE UP HERE

static int recurse_path_find(int n,int visited[n],const connection_t connections[n][n], int src,int dest,int jumps){
    //the visited array is to avoid visting and looping paths, kinda like the concept of dynamic programming
    visited[src] = 1;
    printf("%d %d %d \n",src,dest,jumps);
    fflush(stdout);
    if(src == dest)
        return jumps;
    else if(src > n-1 || src < 0){
        return INT_MAX;
    }
    else{
        for(int i=0;i<n;i++){
            if(connections[src][i].distance!=INT_MAX && connections[src][i].time!=INT_MAX && i!=src){
                int inter_jump = recurse_path_find(n,connections,i,dest,jumps+1);
                if(inter_jump<jumps)
                    jumps=inter_jump;
            }
        }
    }
    return jumps;
}

// YOUR SOLUTIONS BELOW

int q1(int n, const connection_t connections[n][n])
{
    //The question states that every airport should be acessible from every other 
    //Meaning even if one edge has INT_MAX, we can return 0 
    //If none of the edges are "not servicible", we can return 1 
    int is_true = 1;
    for(int i=0;i<n;i++){
        for(int j=0;j<n;j++){
            //INT_MAX is imported as part of limits.h in main file. 
            if(connections[i][j].distance == INT_MAX || connections[i][j].time == INT_MAX){
                is_true = 0;
            }
        }
    }
    return is_true;
}

int q2(const airport_t *src, const airport_t *dest, int n, int k,
       const connection_t connections[n][n])
{
    int visited[n]={0};
    int ans_k = recurse_path_find(visited,n,connections,src->num_id,dest->num_id,0);
    int ans;
    if(ans_k < k)
        ans = 1;
    else 
        ans = 0;
    return ans;
}

int q3(const airport_t *src, int n, const connection_t connections[n][n])
{
    return 0;
}

void q4(int n, int (*predicate_func)(const airport_t *, const airport_t *),
        airport_t airport_list[n])
{

}

pair_t q5(int n, airport_t airports[n])
{
    pair_t ans = {-1, -1};
    return ans;
}

int q6(int n, int amount, const int entry_fee[n])
{
    return 0;
}

void q7(int n, const char *pat, int contains[n], const airport_t airports[n])
{

}

int q8(int n, int trip_order[n - 1], const connection_t connections[n][n])
{
    return 0;
}

int q9(int n, pair_t edges[n - 1], const connection_t connections[n][n])
{
    return 0;
}

void q10(int n, int k, const airport_t *src,
         const connection_t connections[n][n], const int destinations[k],
         int costs[k])
{

}

// END
